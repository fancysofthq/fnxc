primitive Vector(Type T, Size N : SizeLiteral)
  macro specialized
    {% if N == 0 then panic("Vector size must be greater than zero") %}
  end

  static def new(..elements : T) forall T
    {% local elements_size = _call:arguments().elements:size() %}

    var instance = self(T, {{ elements_size }}).new

    {% for i, _ in ipairs(elements_size) %}
      instance[{{ i - 1 }}] = elements[{{ i - 1 }}]
    {% end %}

    return instance
  end

  def [index : U] : T forall U : SizeLiteral
    {% if U >= N then panic("Index out of boundaries") %}

    llvm
      %res = extractelement <{{ N }} x {{ T }}> %self,
        i{{ program:wordsize() }} {{ U }}
      ret %res
    end
  end

  def [index : Size] : T
    if index >= N
      raise IndexError.new(index, N)
    end

    llvm
      %res = extractelement <{{ N }} x {{ T:llvm_type() }}> %self,
        i{{ program:wordsize() }} %arg.index
      ret %res
    end
  end

  def [index : U] = (value : T) : exactself forall U : SizeLiteral
    {% if U >= N then panic("Index out of boundaries") %}

    llvm
      %res = insertelement <{{ N }} x {{ T:llvm_type() }}> %self,
        {{ T:llvm_type() }} %arg.value,
        i{{ program:wordsize() }} {{ U }}
      ret %res
    end
  end

  def [index : Size] = (value : T) : exactself
    if index >= N
      raise IndexError.new(index, N)
    end

    llvm
      %res = insertelement <{{ N }} x {{ T:llvm_type() }}> %self,
        {{ T:llvm_type() }} %arg.value,
        i{{ program:wordsize() }} %arg.index
      ret %res
    end
  end

  def shuffle(other : exactself, mask : Vector(Int32, U)) : Vector(T, U) forall U : SizeLiteral
    llvm
      %res = shufflevector <{{ N }} x {{ T:llvm_type() }}> %self,
        <{{ N }} x {{ T:llvm_type() }}> %arg.other,
        <{{ U }} x i32> %arg.mask
      ret %res
    end
  end
end
