primitive Integer(Bitsize N : UIntLiteral)
  macro specialized
    {%
      if not (N.value >= 1 and N.value <= 8388607) then
        panic("Integer bitsize must be in range of 1..(2^23 - 1)‬")
      end
    %}
  end

  # Sum *self* and *other*, modulo wrapping the result in case of overflow.
  # Also @see `#add`.
  #
  # ```
  # 254u8 %+ 5u8 == 4u8
  # ```
  #
  # @nodoc This method is placed in the common `Integer` module because:
  #
  # > ... LLVM integers use a two’s complement representation,
  # > this [add] instruction is appropriate for both signed and unsigned integers.
  #
  def wadd(other : Integer(O)) : self forall O : UIntLiteral
    \{%
      if O.value > N.value then
        panic("Right operand bitsize can't be greater than the left one")
      end
    %}

    \{% if not N.value == O.value then %}
      llvm
        %temp = bitcast i\{{ O }} %arg.other to i\{{ N }}
        %sum = add i\{{ N }} %self, %temp
      end
    \{% else %}
      llvm
        %sum = add i\{{ N }} %self, %arg.other
      end
    \{% end %}

    llvm
      ret %sum
    end
  end

  # @see `#wadd`.
  % Precedence(10)
  def %+ (other)
    wadd(other)
  end

  # Sum *self* and *other*, returning the same type as *self*.
  #
  # The *other* integer is downcast to self, thus it's illegal
  # if *other* has greater bitsize than *self*.
  #
  # An `ArithmeticOverflow` error would be raised in case of overflow.
  # @see `#wadd` and @see `#sadd` for safer alternatives.
  #
  # ```
  # 1 + 2 == 3      # Ok
  # 1 + 2i64        # Panic! Possible loss of information when downcasting `Int64` to `Int32`
  # 1 + 2i64.to_i32 # Ok, explicit cast
  # 254u8 + 5u8     # `ArithmeticOverflow` error
  # ```
  abstract def add(other : Integer(O)) : self forall O : UIntLiteral

  # @see `#add`.
  % Precedence(10)
  def + (other)
    add(other)
  end

  # Sum *self* and *other* using the saturated arithmetics.
  #
  # ```
  # 1i4 ^+ 2 == 3
  # 6i4 ^+ 6 == 7
  # -4i4 ^+ 2 == -2
  # -4i4 ^+ -5 == -8
  # ```
  abstract def sadd(other : Integer(O)) : self forall O : UIntLiteral

  # @see `#sadd`.
  % Precedence(10)
  def ^+ (other)
    sadd(other)
  end
end

{% for _, unsig in ipairs{false, true} do %}
  module {{ unsig and "Unsigned" or "Signed" }}Integer(Bitsize N)
    derive Integer(N)

    def add(other : Integer(O)) : self forall O : UIntLiteral
      \{%
        if O.value > N.value then
          panic("Right operand bitsize can't be greater than the left one")
        end
      %}

      const overbit = uninitialized Integer(1)

      llvm
        %temp.0 = bitcast i\{{ O }} %arg.other to i\{{ N }}
        %result = call {i\{{ N }}, i1}
          @llvm.{{ unsig and "u" or "s" }}add.with.overflow.i\{{ N }}(
            i\{{ N }} %self, i\{{ N }} %temp.0)
        %temp.1 = extractvalue {i\{{ N }}, i1} %result, 1
        store i1 %temp.1, i1* %const.overbit
      end

      if overbit
        raise ArithmeticOverflow.new
      else
        llvm
          %sum = extractvalue {i\{{ N }}, i1} %result, 0
          ret %sum
        end
      end
    end

    # @nodoc
    def add(other : Integer(N)) : self
      const overbit = uninitialized Integer(1)

      llvm
        %result = call {i\{{ N }}, i1}
          @llvm.{{ unsig and "u" or "s"}}add.with.overflow.i\{{ N }}(
            i\{{ N }} %self, i\{{ N }} %arg.other)
        %temp.0 = extractvalue {i\{{ N }}, i1} %result, 1
        store i1 %temp.0, i1* %const.overbit
      end

      if overbit
        raise ArithmeticOverflow.new
      else
        llvm
          %temp.0 = extractvalue {i\{{ N }}, i1} %result, 0
          ret %temp.0
        end
      end
    end

    def add_saturated(other : Integer(O)) : self forall O : UIntLiteral
      \{%
        if O.value > N.value then
          panic("Right operand bitsize can't be greater than the left one")
        end
      %}

      llvm
        %temp.0 = bitcast i\{{ O }} %arg.other to i\{{ N }}
        %temp.1 = call i\{{ N }}
          @llvm.{{ unsig and "u" or "s" }}add.sat.i\{{ N }}(
            i\{{ N }} %self, i\{{ N }} %temp.0)
        ret %temp.1
      end
    end

    # @nodoc
    def add_saturated(other : Integer(N)) : self
      llvm
        %temp.0 = call i\{{ N }}
          @llvm.{{ unsig and "u" or "s" }}add.sat.i\{{ N }}(
            i\{{ N }} %self, i\{{ N }} %arg.other)
        ret %temp.0
      end
    end
  end
{% end %}

{% for _, i in ipairs{1, 2, 4, 8, 16, 32, 64} do %}
  primitive Int{{ i }}
    derive SignedInteger({{ i }})
  end

  primitive UInt{{ i }}
    derive UnsignedInteger({{ i }})
  end
{% end %}

alias Bit = Int1
alias Bool = Int1
alias Byte = UInt8
alias Size = UInt{{ program.wordsize }}
