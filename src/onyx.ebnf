(*
  At least one sequential expression.
*)
multi_expr = expr, {nl, [expr]};

(*
  A block expression (not used freestanding in the wild).

  ```
  do foo; bar end
  { (foo) }
  ```
*)
block_expr = ("do", [multi_expr], "end") | ("{", [multi_expr], "}");

(*
  ```
  while foo bar
  until (foo) do bar end
  loop { foo }
  ```
*)
loop = ("while" | "until", expr) | "loop", expr | block_expr;

(*
  ```
  foo while bar
  { foo } until (bar)
  ```
*)
delayed_loop = expr | block_expr, ("while" | "until", expr);

condition = "if" | "unless", expr, expr | block_expr, ;

instance_call = expr, [sp], ".", [sp], id, ["(", ];
pointer_call = expr, [sp], "->", [sp], id, ["("];

control =
  "~" | "!" | "@" | "#" | "$" | "%" | "^" | "&" | "*" | "(" | ")" |
  "-" | "+" | "=" | "{" | "}" | "[" | "]" | "<" | ">" | ":" | '"' |
  "'" | "`" | "|" | "?" | "." | "," | "#" | " " | nl;

(*
  A traditional, C-like identifier.

  ```
  foo
  _bar42
  ```
*)
id1 = alpha, {alphanum | underscore};

(*
  An explicit identifier terminated with a control character.

  ```
  `фу == xn--s1ab
  ```
*)
id2 = "`", {any - control}-;

(*
  An explicit identifier terminated with a backtick.

  ```
  `фу бар` == xn---1-8sbc5dlf
  ```
*)
id3 = "`", {any}-, "`";

(*
  An identifier.
*)
id = id1 | id2 | id3;

(*
  A single argument declaration with default value disallowed.

  ```
  foo: bar : in T
  ```
*)
arg_decl_no_default =
  [id, ":", {sp}], id, [{sp}-, ":", {sp}-, type_expr];

(*
  An at least single argument declaration
  with default values disallowed.

  ```
  bar: baz, foo : T
  ```
*)
args_decl_no_default =
  arg_decl_no_default, {{sp}, ",", {sp},  arg_decl_no_default};

(*
  To disguise a freestanding block argument from a pointer call,
  it must have either block arguments or wrapped expression or both.

  NB: Blocks don't have closures and they won't
  allow default values for their arguments.

  ```
  # Pointer call
  -> bar

  # Block arg passing
  -> { bar }                # freestanding_block_arg_1
  -> |bar, baz| do qux; end # freestanding_block_arg_1
  -> || bar                 # freestanding_block_arg_2
  ```
*)

(*
  Block arguments are optional,
  but the expression must be wrapped.
*)
freestanding_block_arg_1 =
  "->", {sp},
  ["|", {sp}, [args_decl_no_default], {sp}, "|", {sp}],
  block_expr;

(*
  Block arguments are required (even empty),
  but the expression won't require wrapping.
*)
freestanding_block_arg_2 =
  "->", {sp},
  "|", {sp}, [args_decl_no_default], {sp}, "|",
  {sp}, expr | block_expr;

freestanding_block_arg =
  freestanding_block_arg_1 |
  freestanding_block_arg_2;

(*
  For cases when we're 100% sure it's a block,
  e.g. when it's an explicit argument.

  ```

  ```
*)
block_arg = "->";

(*
  A call.

    * Parens won't allow whitespaces beforeahead;
    * The last proc or block argument is allowed to follow
      the call (e.g. `foo() ~> bar` or `foo -> { bar }`);
    * There may be multiple procs, but only a single block,
      which must be the last argument.

  ```
  # Valid
  foo(bar)
  foo(bar, baz) -> || qux
  foo(bar, -> qux) # The last argument is a 100% block
  foo ~> bar
  foo(~> |[bar], baz| { qux })
  foo(~> bar, ~> baz) ~> qux

  # Invalid
  foo (bar)
  foo bar
  foo(-> || bar) -> || baz
  ```
*)

(*
  Proc closure is a declaration of variables for a foreign scope.

  ```
  ~> |[final foo : T = foo + bar, let baz = 42]|
  ```
*)
proc_closure_decl =
  "[", {sp}, [expr, {{sp}, ",", {sp}, expr}], {sp}, "]";

(*
  A proc passed as an argument.

  ```
  ~> foo
  ~> |[foo = unsafe foo], bar| { baz }
  ~> |[foo, bar]| : T baz
  ~> : T foo
  ```
*)
proc_as_arg =
  "~>", {sp},
  ["|", {sp}, [
    proc_closure_decl |
    (proc_closure_decl, {sp}, ",", {sp}, [args_decl])
  ], {sp}, "|", {sp}],
  [{sp}-, ":", {sp}-, type_expr],
  expr | block_expr;

call_arg = expr | proc_as_arg | block_arg;

call =
  id,
  ["(", {sp}, [call_arg, {",", {sp}, call_arg}], {sp}, ")"],
  {sp}, [freestanding_block_arg | proc_as_arg];
