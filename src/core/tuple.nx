struct Tuple(..T)
  \{% for t, i in ipairs(T:types()) do %}
    protected var var\{{ i - 1 }} : \{{ t }}
  \{% end %}

  @[NoRaise]
  static def new(tuple : ..T)
    return tuple
  end

  @[NoRaise]
  def initialize(
    \{% for i = 0, T:size() - 1 do %}
      self.var\{{ i }},
    \{% end %}
  )
  end

  @[NoRaise]
  threadsafe const def size
    \{{ T:size() }}
  end

  # Variant A:
  #

  \{% for t, i in ipairs(T:types()) do %}
    threadsafe const def [index :: \{{ i - 1 }}] : \{{ t }}
      return var\{{ i - 1 }}
    end

    threadsafe def [index :: \{{ i - 1 }}] = (val : \{{ t }}) : \{{ t }}
      return var\{{ i - 1 }} = val
    end
  \{% end %}

  @[Undef]
  threadsafe const def [index : I] : Undef forall I : SizeLiteral
  end

  @[Undef]
  threadsafe def [index : I] = (val : Undef) : Undef forall I : SizeLiteral
  end

  # Variant B:
  #

  @[NoRaise]
  threadsafe const
  def [index : I] : \{{ T:types[I:val() + 1] }}
  forall I : SizeLiteral where \{{ I:val() < T:size() }}
    return var\{{ I:val() }}
  end

  @[NoRaise]
  threadsafe
  def [index : I] = (val : \{{ T:types[I:val() + 1] }} ) :
    \{{ T:types[I:val() + 1] }}
  forall I : SizeLiteral where \{{ I:val() < T:size() }}
    return var\{{ I:val() }} = val
  end

  @[MayRaise(IndexError)]
  const def [index : Size] : \{{ T:union() }}
    case index
    \{% for i = 0, T:size() - 1 do %}
      when \{{ i }}; return var\{{ i }}
    \{% end %}
    else
      raise IndexError.new
    end
  end

  @[MayRaise(IndexError)]
  def [index : Size] = (val : \{{ T:union() }}) : \{{ T:union() }}
    case index
    \{% for i = 0, T:size() - 1 do %}
      when \{{ i }}
        return var\{{ i }} = val
    \{% end %}
    else
      raise IndexError.new
    end
  end
end

