class Array(Type T)
  protected getter pointer : T*

  getter capacity : Size
  getter size : Size = 0

  static def {slice : Slice(T, S)} forall S
    const nearest_capacity = 2 ** Math.lg(\{{ S:value() }}).ceil
    const pointer = `malloc(@sizeof(T) * nearest_capacity)
    @memcpy(pointer, &slice, \{{ S:value() }})
    return new(pointer, nearest_capacity, \{{ S:value() }})
  end

  def initialize(self.capacity = 0)
    pointer = if capacity > 0
      unsafe
        `malloc @sizeof(T) * capacity |> @as!! T*
      end
    else
      T*.nil
    end
  end

  def initialize(self.pointer, self.capacity, self.size)
  end

  delegate classrefs -> each

  def finalize
    each -> @deref(self, &)

    unsafe
      `free pointer
    end
  end

  def push(value : T)
    @ref(self, T)

    if size == capacity
      capacity *= 2

      pointer = unsafe
        `realloc pointer, @sizeof(T) * capacity |> @as!! T*
      end
    end

    size += 1

    unsafe
      &pointer[size] = value
    end

    return self
  end

  @[Precedence(10)]
  delegate << -> push

  def each(-> T)
    var i = size - 1
    i.times -> yield self[&]
  end

  def map(T -> U) forall U
    var new = self(U).new(capacity)
    each -> new << yield &
    return new
  end
end
