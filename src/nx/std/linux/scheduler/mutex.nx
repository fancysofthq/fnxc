struct Std::Scheduler::Mutex
  const AlreadyLocked = "Already locked on mutex"
  const NotLockedYet = "Not yet locked on mutex"

  private mut fiber_id : Fiber::ID
  getter locked? : Bool

  # Block until locked the mutex.
  fun lock
    @loop -> do
      if lock?() { return }
      Scheduler.wait(self)
    end
  end

  # Try locking the mutex, immediately returning the result.
  fun lock? : Bool
    prev = @atomget(fiber_id)

    if prev == Fiber.id
      @bug AlreadyLocked
    end

    return @atomreplace(fiber_id, prev, Fiber.id) == prev
  end

  # Try locking the mutex, waiting *until* timeout.
  fun lock?(until time : Time) : Bool
    @loop -> do
      if lock?() { return true }
      const timed_out? = Scheduler.wait(self, time)
      if timed_out? { return false }
    end
  end

  # Try locking the mutex, waiting for *timeout*.
  fun lock?(timeout : Timespan)
    lock?(Time.now + timeout)
  end

  # Unlock the previously locked mutex.
  fun unlock
    if @atomicget(fiber_id) != Fiber.id
      @bug NotLockedYet
    end

    Scheduler.unlock(self)
  end

  # Synchronize a block of code.
  fun sync(until time : Time, ->)
    lock(time)
    const r = yield
    unlock()
    ret r
  end

  fun sync(timeout : Timespan, ->)
    ret sync(Time.now + timeout, yield)
  end
end
