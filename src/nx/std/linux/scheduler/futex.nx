{%
  -- > FUTEX_PRIVATE_FLAG (since Linux 2.6.22)
  if not __target.sys_ver >= "2.6.22" then
    panic("Standard `Scheduler` implemetation requires Linux kernel >= 2.6.22")
  end
%}

private class Scheduler::Futex
  val NoReadAccessToMemory
  val ValueMismatch
  val InvalidFutexAddress
  val Interrupted

  # Wait on the *futex* set to the *expected* value.
  # Immediately returns false if the actual value differs
  # from the expected one. Returns true once awake.
  def wait(futex : $int*, expected : $int, timeout : Timespan~) : Bool
    const ret = unsafe { $futex(
      futex, $FUTEX_WAIT_PRIVATE,
      expected, timeout, 0, 0) }

    case ret
    when 0       return true
    when $EAGAIN return false
    when $EACCES throw NoReadAccessToMemory
    when $EFAULT throw InvalidFutexAddress
    when $EINTR  throw Interrupted
    else
      throw "Unexpected error %i" % ret
    end
  end

  # Wake at most *waiters*. Returns the number of waiters awoken.
  def wake(futex : $int*, waiters : $int) : $int
     unsafe { $futex(
       futex, $FUTEX_WAKE_PRIVATE,
       waiters, 0, 0, 0) }
  end

  # This operation first checks whether the location *futex1* still
  # contains the value *val1*. If not, the operation fails with the
  # error EAGAIN.  Otherwise, the operation wakes up a maximum of
  # *wake_waiters* waiters that are waiting on the futex at uaddr.  If there
  # are more than *wake_waiters* waiters, then the remaining waiters are
  # removed from the wait queue of the source futex at *futex1* and
  # added to the wait queue of the target futex at *futex2*.  The
  # *transfer_waiters* argument specifies an upper limit on the number of
  # waiters that are requeued to the futex at *futex2*.
  #
  # Consider the following
  # scenario, where multiple waiter threads are waiting on B, a
  # wait queue implemented using a futex:
  #
  # ```text
  # lock(A)
  #
  # while (!check_value(V)) {
  #   unlock(A)
  #   block_on(B)
  #   lock(A)
  # }
  #
  # unlock(A)
  # ```
  #
  # Returns the total number of waiters that were woken up or
  # requeued to the futex for the futex word at *futex2*. If this
  # value is greater than *wake_waiters*, then the difference is the number
  # of waiters requeued to the futex for the futex word at *futex2*.
  def cmp_requeue(
    futex1 : $int*,
    val1 : $int,
    wake_waiters : $int,
    futex2 : $int,
    transfer_waiters : UInt32
  )
    unsafe { $futex(
      futex1, $FUTEX_CMP_REQUEUE_PRIVATE,
      wake_waiters, transfer_waiters,
      futex2, val1) }
  end

  enum WakeOp : UInt<4>
    Set    # *futex2 = op_arg
    Add    # *futex2 += op_arg
    Or     # *futex2 |= op_arg
    AndNot # *futex2 &= ~op_arg
    Xor    # *futex2 ^= op_arg

    # Use as `Add | ArgShift`
    ArgShift = 8 # Use `1 << op_arg` instead of `op_arg`
  end

  enum WakeCmp : UInt<4>
    Equal              # if (oldval == cmp_arg) { wake }
    NotEqual           # if (oldval != cmp_arg) { wake }
    LessThan           # if (oldval < cmp_arg) { wake }
    LessThanOrEqual    # if (oldval <= cmp_arg) { wake }
    GreaterThan        # if (oldval > cmp_arg) { wake }
    GreaterThanOrEqual # if (oldval >= cmp_arg) { wake }
  end

  # The FUTEX_WAKE_OP operation is equivalent to executing the
  # following code atomically and totally ordered with respect to
  # other futex operations on any of the two supplied futex words:
  #
  # ```
  # oldval = *futex2
  # *futex2 = oldval op op_arg
  #
  # Futex.wake(futex1, wake1)
  #
  # if (oldval cmp cmp_arg)
  #   Futex.wake(futex2, wake2)
  # end
  # ```
  #
  # In other words, FUTEX_WAKE_OP does the following:
  #
  # * Saves the original value of the futex word at *futex2* and
  #   performs an operation *op* to modify the value of the futex at
  #   *futex2*; this is an atomic read-modify-write memory access
  #   (i.e., using atomic machine instructions of the respective
  #   architecture)
  #
  # * Wakes up a maximum of *wake1* waiters on the futex for the
  #   futex word at *futex1*; and
  #
  # * Dependent on the results of a test *cmp* of the original value of
  #   the futex word at *futex2*, wakes up a maximum of *wake2* wait‚Äê
  #   ers on the futex for the futex word at *futex2*.
  #
  # The operation and comparison that are to be performed are
  # encoded in the bits of the argument val3.  Pictorially, the
  # encoding is:
  #
  #         +---+---+-----------+-----------+
  #         |op |cmp|  op_arg   |  cmp_arg  |
  #         +---+---+-----------+-----------+
  #           4   4      12          12     <== # of bits
  #
  # The return value of is the sum of the number of
  # waiters woken on the futex *futex1* plus the number of waiters
  # woken on the futex *futex2*.
  def wake_op(
    futex1 : $int*,
    wake1 : $int,
    futex2 : $int*,
    wake2 : $int,
    op : WakeOp,
    op_arg : Int<12>,
    cmp : WakeCmp,
    cmp_arg : Int<12>
  )
    mut bitset = BitArray<32>()

    bitset[0] = op
    bitset[4] = cmp
    bitset[8] = op_arg
    bitset[20] = cmp_arg

    unsafe { $futex(
      futex1, $FUTEX_WAKE_OP_PRIVATE,
      wake1, wake2, futex2,

      # Fun fact: the C standard defines `int` to be
      # "at least 16 bits in size.". Still, `val3` is `int`.
      @cast(bitset, Int32))
    ) }
  end
end
