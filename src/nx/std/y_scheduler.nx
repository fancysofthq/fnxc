# 1. We have `threadsafe`, but would it be
# threadsafe with threads other than Scheduler?
# If no, need to build-in the Scheduler then.
#
# Answer is "yes". `threadsafe` is about
# concurrent access, atomics, fences.
#
# 2. What to do with errors raised in promises?
class Scheduler
  protected static var threads : Array(`thrd_t)

  private static {
    var promise_queue = Queue(Promise).new
    const mutex : `mtx_t*
    const monitor : `cnd_t*
    var active_promises_count = 0
    var terminating = false
  }

  static def run(threads_count : Size, proc : ~>)
    unsafe
      mutex = `malloc @sizeof(`mtx_t)
      `mtx_init(mutex, `mtx_timed)
    end

    async(proc)

    const start = ~> loop do
      Scheduler.yield

      if terminating
        break
      end
    end

    threads_count.times do |i|
      const id = uninitialized thrd_t

      const code = unsafe
        `thrd_create(&id, start, &i))
      end

      validate_thread_code!(code)

      threads << id
    end

    threads.each do
      const code = unsafe { `thrd_join(&, nil) }
      validate_thread_code!(code)
    end
  end

  static threadsafe {
    def async(proc : ~> T) : Promise(T) forall T
      const promise = Promise(T).new(proc)

      unsafe { `mtx_lock(mutex) }
      volatile { promise_queue.push(promise) }

      unsafe
        `cnd_broadcast(monitor)
        `mtx_unlock(mutex)
      end

      return promise
    end

    # RFC: Resolve this exact promise with higher priority?
    def await(promise : Promise(T)) : T forall T
      loop do
        @type.yield

        if promise.resolved?
          return unsafe { promise.unsafe_result }
        end
      end
    end

    # NOTE: The sleep time is not exact, as a thread may be busy resolving
    # other promises. Consider using other sleep methods for exact times.
    def sleep(time : Time)
      @type.yield(Time.now + time)
    end

    def sleep(time : Numeric)
      sleep(Time.new(time))
    end

    # Yield current thread to resolve some promises.
    private def yield(until : Time? = nil) : Void
      var locked = false

      loop do
        unless locked
          const code = if time
            unsafe { `mtx_timedlock(mutex, until.utc) }
          else
            unsafe { `mtx_lock(mutex) }
          end

          if code == unsafe { `thrd_timedout }
            return
          elsif code != unsafe { `thrd_success }
            @bug "Unexpected code %d" % code
          end
        end

        volatile
          if terminating { break }

          if const promise = promise_queue.shift?
            active_promises_count += 1
            unsafe { `mtx_unlock(mutex) }
            locked = false

            promise.resolve

            unsafe { `mtx_lock(mutex) }
            active_promises_count -= 1
            unsafe { `cnd_broadcast(monitor) }
            unsafe { `mtx_unlock(mutex) }

            break

          elsif active_promises_count > 0
            if time
              unsafe { `cnd_timedwait(monitor, mutex, until.utc) }
            else
              unsafe { `cnd_wait(monitor, mutex) }
            end

            locked = true

          else
            # Once we've caught a condition when
            # there are neither queued nor active promises,
            # all threads are scheduled for termination.
            #

            terminating = true
            unsafe { `mtx_unlock(mutex) }
            break

          end
        end
      end
    end

    private def validate_thread_code!(code : `int)
      case i
      when `thrd_success; return
      when `thrd_timedout; @bug "Unexpected thread timed out"
      when `thrd_busy; @bug "Thread unavailable"
      when `thrd_nomem; raise OutOfMemory.new
      when `thrd_error; raise UnhandledError.new
      else
        @bug "Unhandled thread return code %d" % i
      end
    end
  }
end

