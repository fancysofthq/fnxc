import "threads"
import "linux/futex"

struct Scheduler
  struct Thread
    const handler : $thrd_t
    const queue : Deque<&Proc<(Void)>>*
    const mutex : Mutex*
  end

  private const pool : Pool
  private const threads : List<Thread*>
  private const thread_limit : UInt8

  @[Threadlocal]
  private const queue : Deque<&Proc<(Void)>>

  @[Threadlocal]
  private const queue_mutex : Mutex

  static fun run(thread_limit : UInt8, ~>)
    const instance = self(thread_limit)
    instance.async(yield)
    instance.run()
  end

  fun initialize(self.thread_limit)
    thread_limit.times ~> (index) do
      mut t = @memalloc(Thread)
      const payload = @memalloc(Tuple<Scheduler*, Thread*>)
      unsafe { $thrd_create(t->&handler, onyx_thread_start, &payload) }
      threads.push(t)
    end
  end

  fun finalize
    threads.each ~> unsafe { @memfree(&) }
  end

  export void onyx_thread_start(void *arg) {
    const payload = unsafe { @cast(arg, Tuple<Scheduler*, Thread*>*) }

    *payload[1]->queue = *payload[0] |> unsafe { &.&(private)queue }
    *payload[1]->mutex = *payload[0] |> unsafe { &.&(private)mutex }
    const self : Scheduler* = *payload[1]

    unsafe { @memfree(payload) }

    @loop ~> do
      if proc = queue.shift?
        @[NoRaise] proc()
      elsif threads.size > 1
        mut stole? = false

        threads.each ~> (other) do
          # Skip the same thread
          if (self == other) { continue }

          # Steal a half of the jobs from another thread
          if steal(self, other)
            stole? = true
            break
          end
        end

        if !stole?
          wait_for_job()
        end
      else
        # There are no jobs in the queue, and this is the only thread.
        # The program should terminate then
        break
      end
    end
  }

  private fun steal(to : Thread*, from : Thread*) : Size
    from->mutex->lock()
    const fq = from->queue

    if fq->size > 0
      to->mutex->lock()

      const tq = to->queue
      const count = fq->size // 2

      tq->resize(count)

      unsafe { @memcopy(
        source: fq->(private)pointer[fq->(private)offset],
        destination: fq->(private)pointer,
        size: count * @sizeof(Job)) }

      fq->(private)offset += count
      tq->(private)size = count

      to->mutex->unlock()
      from->mutex->unlock()

      ret count
    else
      from->mutex->unlock()
      ret 0
    end
  end

  private fun wait_for_jobs
  end

  fun run
    threads.each ~> $thrd_join(&.handler)
  end

  static fun wait(mutex : Mutex, until time : Time~)
  end

  static fun unlock(mutex : Mutex)
  end

  static fun wait(covar : Covar, mutex : Mutex, until time : Time~)
  end

  static fun signal(covar : Covar)
  end

  static fun broadcast(covar : Covar)
  end

  static fun wait_readable(fd : File::Descriptor, until time : Time~)
  end

  static fun wait_writeable(fd : File::Descriptor, until time : Time~)
  end
end
