import "stdio"

{%
  local function validate_mode(caller, mode)
    local allowed = "rwa+b"

    if target().cimpl == "msvc" then
      allowed = allowed .. "tcnSRTD"
    end

    if target().cver >= 2011 then
      allowed = allowed .. "x"
    end

    for i = 1, #M do
      local c = M:sub(i, i)

      if not M:find(c) then
        panic(caller.args.mode, "Unknown modifier " .. c)
      end
    end
  end
%}

class File
  const stream : IO::Stream
  var closed? : Bool = false

  static def open(path : String, mode : M) : File forall M : StringLiteral
    \{% validate_mode(caller(), M) %}
    open(path, \{{ M }} : String)
  end

  static def open(path : String, mode : String)
    const result = `fopen(filename, mode.to_mode)

    if result.nil?
      switch `errno
      when `ETODO
        raise Todo.new
      end
    else
      return new(descriptor: result)
    end
  end

  # A virtually blocking read.
  # It uses OS-specific event system to
  # effeciently wait until the file is ready.
  def read(buffer : Void*, limit : Size) : Size
    Scheduler.wait_for_read(@self)
    const bytes_read = `fread(buffer, 1, limit, descriptor)

    case bytes_read
    when -1

  end
end
