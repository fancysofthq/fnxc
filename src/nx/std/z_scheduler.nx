# `onyx main.nx --libc=gnu --libc=custom --std=./src/std`
{% if _target.libc == "musl" then %}
  import "threads.h"
{% else %}
  import "pthread.h"
{% end %}

class Scheduler
  static var queue = Deque(Promise).new
  static var queue_mutex = Mutex.new
  static var queue_signal = Signal.new

  @[ThreadLocal]
  static var local_queue = Deque(Promise).new

  static threadsafe
  def async(local : Bool = false, proc : ~> T) : Promise(T) forall T
    const promise = Promise(T).new(proc)

    if local
      volatile { local_queue.push(promise) }
    else
      queue_mutex.sync(queue_signal) ~> queue.push(promise)
    end

    return promise
  end

  static threadsafe
  def await(promise : Promise(T)) : T forall T
    @loop do
      promise.mutex.lock

      if @atomic.get(promise.resolved?)
        promise.mutex.unlock
        return promise.result
      end

      queue_mutex.lock

      if var another = volatile { queue.shift? }
        queue_mutex.unlock
        promise.mutex.unlock
        volatile { another.resolve }
      else
        select
        when queue_signal.wait(queue_mutex)
        when promise.signal.wait(promise.mutex)
        end
      end
    end
  end

  # Wait for all *promises* to resolve, returning a `Tuple` of their results.
  static threadsafe
  def await(..promises : T) : Undef forall T : Promise
    return (
      {% for _, i in T %}
        await(promises[{{ i }}]),
      {% end %}
    )
  end

  # Wait for **the first** of the *promises* to resolve, returning its result.
  # Other promises continue to execute, but their return values are ignored
  # from now on. NOTE: If a error is raised in a slower promise, it would be
  # completely ignored then, i.e. thrown to nowhere.
  static threadsafe
  def select(..promises : T) : T forall T : Promise
    # ?
  end

  static threadsafe def sleep(for : Timespan)
    var timer = Timer.new(for)

    loop do
      if timer.done?
        break
      end

      queue_mutex.lock

      if var another = queue.shift?
        queue_mutex.unlock
        another.resolve
      else
        select
        when queue_signal.wait(queue_mutex)
        when timer.wait
        end
      end
    end
  end
end

macro @async(local : BoolLiteral = false, ~>)
  Scheduler.async(\{{ local }}) do
    \{{ if local:value() then "threadsafe" end }}
      \{{ yield }}
    \{{ if local:value() then "end" end }}
  end
end

macro @await(..promises)
  Scheduler.await(\{{ promises }})
end

macro @select(..promises)
  Scheduler.select(\{{ promises }})
end
