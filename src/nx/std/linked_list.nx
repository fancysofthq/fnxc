class LinkedList(T)
  derive Enumerable(T)

  private struct Node(T)
    @[NoRef] var data : T
    var next : Node(T)*?
  end

  private var head : Node(T)*?

  \{% if T:contains_class() then %}
    def references?(value : T) : Bool
      return any? -> @same?(&, value)
    end

    def referencees(T ->) : Void
      each -> if &.class? { yield & }
    end
  \{% end %}

  def finalize
    var next : Node(T)*? = head
    var prev = uninitialized Node(T)*?

    until next.nil?
      prev = next
      next = unsafe { *next }.next
      @deref(self, (unsafe { *prev }).data)
      unsafe { `free(prev) }
    end
  end

  def size : Size
    var counter = 0s
    var next : Node(T)*? = head

    until next.nil?
      counter += 1
      next = unsafe { *next }.next
    end

    return counter
  end

  def each(T ->) : Void
    var next : Node(T)*? = head

    until next.nil?
      yield unsafe { *next }.data
      next = unsafe { *next }.next
    end
  end

  def includes?(value : T) : Bool
    return any? -> & == value
  end

  def === (...) : Bool
    return includes?(...)
  end

  def push(value : T) : self
    if head.nil?
      &head = allocate_node()
      head.data = value
      head.next = nil
    else
      var prev_node = head
      var next_node = *head.next

      until next_node.nil?
        prev_node = next_node
        next_node = *next_node.next
      end

      &next_node = allocate_node()
      next_node.data = value
      prev_node.next = next_node
    end

    @ref(self, value)
    return self
  end

  def pop : T
    var curr : Node(T)*? = head

    if curr.nil?
      raise IndexError.new
    end

    var next : Node(T)*? = (unsafe { *curr }).next

    if next.nil?
      var value = (unsafe { *curr }).data
      @deref(self, value)
      unsafe { `free(curr) }
      return value
    end

    until next.nil?
      curr = next
      next = (unsafe { *curr }).next
    end

    var value = (unsafe { *curr }).data
    @deref(self, value)
    unsafe { `free(*prev.next) }

    return value
  end

  private def allocate_node : Node(T)*
    return unsafe { `malloc(@sizeof Node(T)).as! Node(T)* }
  end
end
