# `do` is an immediate block statement,
# it can either use `end` or brackets (`{}`).
#
# `do` equals to `-> do`.
# `->` (thin arrow) is immediate code block
# ought to be inlined.
# `~>` (curly arrow) is a delayed proc.
#
# It can be an argument, and it
# won't require a comma if it's the last,
# e.g. `each 3 do foo; end`, but it would if
# wrapped in parentheses: `each(e, do foo; end)`
#

each do
  foo
end

each(do
  foo
end)

each do { foo }
each(do { foo })

each -> do
  foo
end

each -> do { foo }
each -> foo

each ~> do { foo }
each ~> do
  foo
end

each ~> foo

def foo
  var x = Box{42}
  var proc : Proc

  # Can never be an inline block!
  # Must have argument types!
  var proc1 = ~> do (y : Int32)
    x.value += y
  end

  @p @typeof(proc1) # => Proc(Int32, Int32)

  get "/" ~> &.response << "Hello, world!"
  get "/" ~> do foo; end
  get "/" ~> do { foo }
  get "/" ~> do (env) env.foo; end
  get "/" ~> do (env) { env.foo }
  get "/" ~> do (var env : HTTP::Context) : Void
    env.response << "Hello, world!"
  end

  each(-> do { @p e })

  5.times -> do
    @p &
  end

  @async ~> @p "yes"
end


if ready?
  do_stuff
end

# They all declare args,
# thus must wrap in parens
# (Rescue w/o backtrace = catch)
rescue (e : Err, trace) : Void
catch ()
do ()

[1, 2].each do (: Int32) @p &; end
var g = [1, 2].map(: -> Float32)
g.resume(-> & * 2.5)

each -> (a : Int32 | Float32) @p a

# Follows the same rules as defs
# (constant args by default, inferring).
# `forall` and `where` are not supported
-> do (x, y) : z
